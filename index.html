<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <title>SHA-3 (Keccak) | CS 205 Project 2015</title>
	<!-- core CSS -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/font-awesome.min.css" rel="stylesheet">
    <link href="css/animate.min.css" rel="stylesheet">
    <link href="css/owl.carousel.css" rel="stylesheet">
    <link href="css/owl.transitions.css" rel="stylesheet">
    <link href="css/prettyPhoto.css" rel="stylesheet">
    <link href="css/main.css" rel="stylesheet">
    <link href="css/responsive.css" rel="stylesheet">
    <!--[if lt IE 9]>
    <script src="js/html5shiv.js"></script>
    <script src="js/respond.min.js"></script>
    <![endif]-->       
    <link rel="shortcut icon" href="images/ico/favicon.ico">
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="images/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="images/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="images/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="images/ico/apple-touch-icon-57-precomposed.png">
</head><!--/head-->

<body id="home" class="homepage">

    <header id="header">
        <nav id="main-menu" class="navbar navbar-default navbar-fixed-top" role="banner">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="index.html"><img src="images/logo.png" alt="logo"></a>
                </div>
				
                <div class="collapse navbar-collapse navbar-right">
                    <ul class="nav navbar-nav">
                        <li class="scroll active"><a href="#home">Home</a></li>                      
                        <li class="scroll"><a href="#meet-team">Team</a></li>
                        <li class="scroll"><a href="#bg-motivation">Background</a></li>                        
                        <li class="scroll"><a href="#application">Application</a></li> 
                        <li class="scroll"><a href="#portfolio">Analysis</a></li>                      
                        <li class="scroll"><a href="#insights">Insights</a></li> 
                        <li class="scroll"><a href="#takeaways">Takeaways</a></li> 
                        <li><a href="https://github.com/vinayps/cs205_project" target="_blank">GitHub</a></li> 
                    </ul>
                </div>
            </div><!--/.container-->
        </nav><!--/nav-->
    </header><!--/header-->

    <section id="main-slider">
        <div class="owl-carousel">
            <div class="item" style="background-image: url(images/slider/bg1.png);">
                <div class="slider-inner">
                    <div class="container">
                        <div class="row">
                            <div class="col-sm-6">                                
                            </div>
                        </div>
                    </div>
                </div>
            </div><!--/.item-->
            <div class="item" style="background-image: url(images/slider/bg2.jpg);">
                <div class="slider-inner">
                    <div class="container">
                        <div class="row">
                            <div class="col-sm-6">                                
                            </div>
                        </div>
                    </div>
                </div>
            </div><!--/.item-->
    </section><!--/#main-slider-->

   <section id="meet-team">
        <div class="container">
            <div class="section-header">
                <h2 class="section-title text-center wow fadeInDown">Meet The Team</h2>                
            </div>

            <div class="row">
                <div class="col-sm-6 col-md-3 col-md-offset-3">
                    <div class="team-member wow fadeInUp" data-wow-duration="400ms" data-wow-delay="0ms">
                        <div class="team-img">
                            <img class="img-responsive" src="images/team/vinay.jpg" alt="">
                        </div>
                        <div class="team-info">
                            <h3>Vinay</h3>
                        </div>
                    </div>
                </div>
                <div class="col-sm-6 col-md-3">
                    <div class="team-member wow fadeInUp" data-wow-duration="400ms" data-wow-delay="100ms">
                        <div class="team-img">
                            <img class="img-responsive" src="images/team/victor.jpg" alt="">
                        </div>
                        <div class="team-info">
                            <h3>Victor</h3>
                        </div>                    
                    </div>
                </div>
        
    </section><!--/#meet-team-->
    <section id="bg-motivation">
        <div class="container">
            <div class="section-header">
                <h2 class="section-title text-center wow fadeInDown">Background and motivation</h2>
                <p class="text-left wow fadeInDown">
                    Cryptographic hash functions are an important component in ensuring the integrity of data without revealing the underlying input. A cryptographic hash function will perform a deterministic, one-way map of some input from an arbitrarily large space, to a much smaller output space (e.g. 1024 bits.) It should be resistant to attempts to discover the underlying input, and be difficult to find inputs with outputs that collide.
                    These functions are often used to verify the integrity of files or data being transferred over a public network, or verify the equality of passwords without directly comparing the plaintext version. More recently, these hash functions have been used in cryptocurrencies like Bitcoin.
                    SHA-3 is an evolution of the SHA hashing algorithm, designed to use different mechanisms to SHA-2 in order to diversify potential vulnerabilities. The official variant of SHA-3 is known as “Keccak.” It is used as the hashing function in Ethereum, a cryptocurrency platform.
                    Depending on the input size, this hash function can be computationally expensive to calculate. We attempt to solve this using both high-level parallelism, and instruction-level parallelism.
                    <ul class="text-left wow fadeInDown">
                        <li>https://en.wikipedia.org/wiki/Cryptographic_hash_function</li>
                        <li>https://en.wikipedia.org/wiki/Ethereum</li>
                    </ul>
                </p>
            </div>            
        </div>
    </section>


    <section id="data">
        <div class="container">
            <div class="section-header">
                <h2 class="section-title text-center wow fadeInDown">Data</h2>
                <p class="text-left wow fadeInDown">
                    The data in this case can be any arbitrary binary input. So essentially any computer file can be used as an input regardless of whether it contains strings, numbers etc.
                    Our application also enables input by message string in addition to file input.

                    In the process of testing, we use synthetic data files generated using random data piped from /dev/urandom.
                </p>
            </div>            
        </div>
    </section>


    <section id="application">
        <div class="container">
            <div class="section-header">
                <h2 class="section-title text-center wow fadeInDown">The Application</h2>
                <p class="text-left wow fadeInDown">
                    The program design is straight-forward: we provide a command line interface that allows users to calculate the result of the SHA-3 (Keccak) hash function subject to different input parameters. The input format is either a file, or a message string. Importantly, both the parameters of the Keccak function (like output size) and the parameters of the tree will change the output so we must allow those parameters to be user-specified. We approached the problem by using both multi-core/multi-thread CPU parallelism, and instruction-level parallelism (AVX/AVX2). Specifically, in the tree hashing approach we first chunk up the input message and process multiple chunks in parallel. Then, using instruction-level parallelism we speed up the processing of each of the tree node processes. Thus, using this kind of a hierarchical approach we are able to see a significant speed-up in performance - more so than either approach would provide on its own. 
                    
                </p>

                <p class="text-left wow fadeInDown">
                    The application is a command-line application that takes the input file/message and the parameters as arguments. Specifically, the following parameters are available:
                    <ul>
                        <li>Tree height</li>
                        <li>Degree of the tree</li>
                        <li>Output length (in bits)</li>
                        <li>The input file or message string</li>
                    </ul>

                </p>
            </div>            
        </div>
    </section>
    <section id="animated-number">
        <div class="container">
            <div class="section-header">
                <h2 class="section-title text-center wow fadeInDown">Speedup (time reduction percentage)</h2>
                <p class="text-center wow fadeInDown">Some quick statstics about performance with AVX and tree hashing.</p>
            </div>

            <div class="row text-center">
                <div class="col-sm-4 col-xs-6">
                    <div class="wow fadeInUp" data-wow-duration="400ms" data-wow-delay="0ms">
                        <div class="animated-number" data-digit="45" data-duration="1000"></div>
                        <strong>AVX (%)</strong>
                    </div>
                </div>
                <div class="col-sm-4 col-xs-6">
                    <div class="wow fadeInUp" data-wow-duration="400ms" data-wow-delay="100ms">
                        <div class="animated-number" data-digit="52" data-duration="1000"></div>
                        <strong>TREE HASHING (%)</strong>
                    </div>
                </div>
                <div class="col-sm-4 col-xs-6">
                    <div class="wow fadeInUp" data-wow-duration="400ms" data-wow-delay="300ms">
                        <div class="animated-number" data-digit="70" data-duration="1000"></div>
                        <strong>AVX + TREE HASHING (%)</strong>
                    </div>
                </div>                             
            </div>
        </div>
    </section><!--/#animated-number-->

    <section id="portfolio">
        <div class="container">
            <div class="section-header">
                <h2 class="section-title text-center wow fadeInDown">Analysis</h2>
                <p class="text-center wow fadeInDown">We processed the results of SHA-3 (Keccak) hashing using AVX, tree hashing, and AVX + tree hashing. The figures below show the significant processing speed gains that can be achieved.</p>
            </div>

            <div class="portfolio-items">
                <div class="portfolio-item tree">
                    <div class="portfolio-item-inner">
                        <img class="img-responsive" src="images/results/tree_hashing_and_avx_percent.png" alt="">
                        <div class="portfolio-info">
                            <h3>Results - Time reduction percentage</h3>
                            Graph
                            <a class="preview" href="images/results/tree_hashing_and_avx_percent.png" rel="prettyPhoto"><i class="fa fa-eye"></i></a>
                        </div>
                    </div>
                </div><!--/.portfolio-item-->
                
                <div class="portfolio-item tree">
                    <div class="portfolio-item-inner">
                        <img class="img-responsive" src="images/results/tree_hashing_and_avx_speedup.png" alt="">
                        <div class="portfolio-info">
                            <h3>Results - Speed-up</h3>
                            Graph
                            <a class="preview" href="images/results/tree_hashing_and_avx_speedup.png" rel="prettyPhoto"><i class="fa fa-eye"></i></a>
                        </div>
                    </div>
                </div><!--/.portfolio-item-->

                <div class="portfolio-item tree">
                    <div class="portfolio-item-inner">
                        <img class="img-responsive" src="images/results/results.png" alt="">
                        <div class="portfolio-info">
                            <h3>Results - Data table</h3>
                            Table
                            <a class="preview" href="images/results/results.png" rel="prettyPhoto"><i class="fa fa-eye"></i></a>
                        </div>
                    </div>
                </div><!--/.portfolio-item-->
            </div>

        </div><!--/.container-->
    </section><!--/#portfolio-->

    <section id="results">
        <div class="container">
            <div class="section-header">
                <h2 class="section-title text-center wow fadeInDown">Results</h2>
                <h3>AVX results</h3>
                <p class="text-left wow fadeInDown">
                	Results - 45% speed up. Used AVX in many of the compute intensive parts of the code. We didnt convert the whole thing to AVX so some overhead in serializing back and forth. Also, a lot of the operations didnt lend themselves to an 8 way parallel effort - in fact, in many cases only 5 of the registers were in use.
One of the most compute intensive parts that we didnt AVX was bit rotation (also called circular shifts). Incidentally, starting with AVX512, circular shifts become intrinsic operations. In fact, even today, in other SIMD instruction sets, like those offered by AMD this is a feature but not on our Intel chips. 
The other challenge was figuring out the correct data type conversions between Python and Cython/C/AVX types. As we are dealing with bit strings, hexadecimal strings, bytearrays, char strings and arrays and most importantly going back and forth between a weakly typed language like Python and a strongly typed one like C, it was difficult. Also dealing with more complex Python objects like lists and their conversions to more primitive types was challenging. 
Finally, one other challenge related to both the previous ones was the fact that Python integers seemed to have a much higher value range than long integers in C. And we are fundamentally limited by 256 bit registers in AVX, and so to store 8 values, each can at max be of 32 bits in length. This meant that some of the larger bit shifts (bit shifting by 64) were hard without a lot of tedious and mistake-prone type conversions. And hence, our choice of implementing Keccakf(400). In this case, the width of the hashing function is only 400 and not 1600 like in the original implementation. This meant that the max bit shift that we had to deal with was only shifts by 16! 
Thus, overall, leveraging AVX for this application, although rewarding was extremely challenging. One definite takeaway (and our TA advisor did hint at this) is to implement completely in C without dealing with the challenges of going back and forth with Python. 
AVX also produced substantial gains in performance (40-50% time reduction) despite all of the type conversions, serializing, and the fact that it wasnt all done in AVX.
Implementation - We started off using the AVX framework that we had available to us. We then extended it by adding functions that we needed like the ability to permute in place, bit shifts, and integer operations in general as opposed to the floating point operations from earlier. Since, we werent converting the entire script to AVX due to above challenges, we had to identify the appropriate areas to parallelize and carefully choose compute intensive areas that could benefit from this parallelization. We also ensured that we tested continuously using other independent implementations as checking the correctness of the algorithm is impossible without a reference (correct and incorrect hashes of the same size are not obviously different). 

                </p>
                </p>
                </p>
                <h3>Tree hashing results</h3>
                <p class="text-left wow fadeInDown">                    
                    Tree hashing allowed for CPU/multi-core parallelism in calculating the hash function for nodes in the tree. Bits from the input are distributed to the leaves in the tree, and then hash values are recursively calculated up the tree. The hash value for the root node is the final result. This way, each layer of the tree could be computed in parallel at the very least. The result is around 50 - 55% reduction in processing time, which increases as the size of the input increases. This makes sense since the fixed overheads from setting up the tree are amortized over larger input sizes. The theoretical upper bound on my laptop (2 cores with hyperthreading) should be a bit over 2x speedup, so this result is not too bad.
                </p>
                <p class="text-left wow fadeInDown">                    
                    One area that we optmised was the allocation of bits to the leaves of the tree. Using the reference algorithm, this step is particularly slow in Python. Note that the resulting hash value is going to depend on the parameters of the tree, so it cannot be directly compared to the hash value returned by a serial implementation (or even a differently parameterised tree hash).
                </p>
                <p class="text-left wow fadeInDown">
                    <h3>AVX + Tree hashing results</h3>
                    
                </p>
            </div>            
        </div>
    </section>

    <section id="insights">
        <div class="container">
            <div class="section-header">
                <h2 class="section-title text-center wow fadeInDown">Insights and improvements</h2>
                <p class="text-left wow fadeInDown">
                    What interesting insights did you gain from this project?
                    <ul>
                        <li>How to combine both high-level and low-level parallelism to gain singificant speed increases.</li>
                        <li>Correctly coding cryptographic functions is hard.</li>
                    </ul>
                </p>
                <p class="text-left wow fadeInDown">
                    What extensions and improvements can you suggest?
                    <ul>
                        <li>Overhead from Python is still significant when operating on file data; it would be better to use Cython or a lower-level language.</li>
                        <li>GPU calculations using OpenCL/CUDA</li>
                    </ul>
                </p>
            </div>            
        </div>
    </section>

    <section id="takeaways">
        <div class="container">
            <div class="section-header">
                <h2 class="section-title text-center wow fadeInDown">Takeaways</h2>
                <p class="text-left wow fadeInDown">
                    Using both tree-hashing and instruction-level parallelism, we saw significant performance gains in the computation of SHA-3 hash values.
                    Interesting insights we gained from this project:
                    <ul>
                        <li>Greater understanding of cryptographic hash functions. We didn't realise that the tree hashing would change the resulting digest value depending on the parameters. However, tree hashing is provably secure in the same way as the serial implementation.</li>
                        <li>Appreciation for the significant speed gains possible from using low-level instruction-level optimisations.</li>
                    </ul>

                    There were a few things we particularly enjoyed from this project:
                    <ul>
                        <li> Understanding and learning to implement a very technical implementation purely on the basis of an academic paper. Seeing the resulting speedup.</li>
                        <li>Gaining a deeper insight into the significant lower-level speedups possible through AVX, and how to translate traditional operations into AVX operations.</li>
                    </ul>

                    The biggest (and most frustrating) challenge was trying to get AVX to work properly. There was significant debugging that was required, and the corner cases meant extensive testing needed to be done in order to ensure correctness.                    

                </p>
                <p class="text-left wow fadeInDown">
                    For next time, we would implement it all in a lower-level language like C++ in order to get maximum speedup and avoid the significant overhead from high-level languages like Python. In addition, it seems AVX is better supported and documented when being run directly with lower-level languages like C rather than intermediate languages like Cython.
                </p>
            </div>            
        </div>
    </section>


    
    <footer id="footer">
        <div class="container">
            <div class="row">
                <div class="col-sm-6">
                    &copy; 2015. Website template "Multi" by <a target="_blank" href="http://shapebootstrap.net/" title="Free Twitter Bootstrap WordPress Themes and HTML templates">ShapeBootstrap</a>
                </div>                
            </div>
        </div>
    </footer><!--/#footer-->

    <script src="js/jquery.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/owl.carousel.min.js"></script>
    <script src="js/mousescroll.js"></script>
    <script src="js/smoothscroll.js"></script>
    <script src="js/jquery.prettyPhoto.js"></script>
    <script src="js/jquery.isotope.min.js"></script>
    <script src="js/jquery.inview.min.js"></script>
    <script src="js/wow.min.js"></script>
    <script src="js/main.js"></script>
</body>
</html>
